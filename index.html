<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>石子对弈游戏</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background-color: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 20px;
            width: 800px;
            max-width: 95vw;
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 20px;
        }

        .status {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            height: 30px;
        }

        .score-display {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .board {
            display: flex;
            flex-direction: column;
            gap: 50px;
            margin-bottom: 20px;
        }

        .player-row {
            display: flex;
            justify-content: space-between;
            position: relative;
        }

        .player-label {
            position: absolute;
            left: -70px;
            top: 50%;
            transform: translateY(-50%);
            font-weight: bold;
            color: #3498db;
        }

        .player-row.system .player-label {
            color: #e74c3c;
        }

        .pit {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: #f0d9b5;
            border: 3px solid #b58863;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            padding: 5px;
            cursor: pointer;
            position: relative;
        }

        .pit.selectable:hover {
            background-color: #dcc194;
            transform: scale(1.05);
            transition: all 0.2s;
        }

        .pit-index {
            position: absolute;
            top: -25px;
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }

        .stone {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin: 5px;
            background-color: #333;
            transition: all 0.3s ease;
        }

        .controls {
            margin-top: 30px;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        button {
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            background-color: #3498db;
            color: white;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        .direction-buttons {
            display: none;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .game-over-message {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
        }

        .game-over-message h2 {
            margin-top: 0;
            color: #2c3e50;
        }

        .restart-button {
            margin-top: 20px;
            background-color: #2ecc71;
        }

        .restart-button:hover {
            background-color: #27ae60;
        }

        .rps-container {
            text-align: center;
            margin-bottom: 20px;
        }

        .rps-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
        }

        .rps-option {
            padding: 10px 20px;
            border-radius: 5px;
            border: 2px solid #3498db;
            background-color: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        .rps-option:hover {
            background-color: #ecf0f1;
            transform: scale(1.05);
        }

        .selected-pit {
            background-color: #dcc194;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(220, 193, 148, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 193, 148, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 193, 148, 0); }
        }

        .moving-stone {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #333;
            z-index: 100;
            transition: all 0.5s ease;
        }
    </style>
</head>
<body>
<div class="game-container">
    <h1>石子对弈游戏</h1>

    <div class="rps-container" id="rpsContainer">
        <h2>用石头剪子布决定谁先手</h2>
        <p>请选择：</p>
        <div class="rps-options">
            <div class="rps-option" data-choice="石头">石头</div>
            <div class="rps-option" data-choice="剪子">剪子</div>
            <div class="rps-option" data-choice="布">布</div>
        </div>
        <p id="rpsResult" style="height: 20px; margin-top: 15px;"></p>
    </div>

    <div class="status" id="gameStatus"></div>

    <div class="score-display">
        <div>玩家得分: <span id="playerScore">0</span></div>
        <div>系统得分: <span id="systemScore">0</span></div>
    </div>

    <div class="board">
        <div class="player-row system">
            <div class="player-label">系统</div>
            <div class="pit" id="system-0"><div class="pit-index">6</div></div>
            <div class="pit" id="system-1"><div class="pit-index">7</div></div>
            <div class="pit" id="system-2"><div class="pit-index">8</div></div>
            <div class="pit" id="system-3"><div class="pit-index">9</div></div>
            <div class="pit" id="system-4"><div class="pit-index">10</div></div>
        </div>
        <div class="player-row player">
            <div class="player-label">玩家</div>
            <div class="pit" id="player-0"><div class="pit-index">1</div></div>
            <div class="pit" id="player-1"><div class="pit-index">2</div></div>
            <div class="pit" id="player-2"><div class="pit-index">3</div></div>
            <div class="pit" id="player-3"><div class="pit-index">4</div></div>
            <div class="pit" id="player-4"><div class="pit-index">5</div></div>
        </div>
    </div>

    <div class="direction-buttons" id="directionButtons">
        <button id="clockwiseBtn">顺时针</button>
        <button id="counterClockwiseBtn">逆时针</button>
    </div>

    <div class="controls">
        <button id="startGameBtn" style="display: none;">开始游戏</button>
        <button id="rulesBtn">查看规则</button>
    </div>
</div>

<div class="game-over-overlay" id="gameOverOverlay">
    <div class="game-over-message">
        <h2 id="winnerMessage"></h2>
        <p id="finalScore"></p>
        <button class="restart-button" id="restartBtn">再来一局</button>
    </div>
</div>

<script>
    // 游戏常量
    const NUM_PITS = 5;
    const INITIAL_STONES = 4;
    const TOTAL_STONES = NUM_PITS * INITIAL_STONES * 2;
    const WINNING_THRESHOLD = Math.floor(TOTAL_STONES / 2) + 1;

    // 游戏状态
    // !!!!update
    // 修改游戏状态，添加AI难度设置
    let gameState = {
        board: [
            [INITIAL_STONES, INITIAL_STONES, INITIAL_STONES, INITIAL_STONES, INITIAL_STONES], // 玩家
            [INITIAL_STONES, INITIAL_STONES, INITIAL_STONES, INITIAL_STONES, INITIAL_STONES]  // 系统
        ],
        score: [0, 0], // [玩家分数, 系统分数]
        currentPlayer: -1, // -1: 未定, 0: 玩家, 1: 系统
        gameStarted: false,
        gameOver: false,
        selectedPit: null,
        isAnimating: false,
        moveCount: 0,
        aiDifficulty: 1 // 默认为中等难度: 0-简单, 1-中等, 2-困难

    };
    // ++++new
    // 添加难度选择和显示HTML
    // ++++new
    // 添加难度选择和显示HTML
    // ++++new
    // 添加难度选择和显示HTML
    const difficultyHTML = `
<div class="difficulty-container" id="difficultyContainer">
    <h2>选择AI难度</h2>
    <div class="difficulty-options">
        <div class="difficulty-option" data-difficulty="0">简单</div>
        <div class="difficulty-option selected" data-difficulty="1">中等</div>
        <div class="difficulty-option" data-difficulty="2">困难</div>
    </div>
</div>

<div class="difficulty-display" id="difficultyDisplay" style="display: none;">
    <div class="difficulty-badge">
        AI难度: <span id="currentDifficulty">中等</span>
    </div>
</div>
`;


    // DOM 元素
    const gameStatus = document.getElementById('gameStatus');
    const playerScore = document.getElementById('playerScore');
    const systemScore = document.getElementById('systemScore');
    const rpsContainer = document.getElementById('rpsContainer');
    const rpsResult = document.getElementById('rpsResult');
    const rpsOptions = document.querySelectorAll('.rps-option');
    const directionButtons = document.getElementById('directionButtons');
    const clockwiseBtn = document.getElementById('clockwiseBtn');
    const counterClockwiseBtn = document.getElementById('counterClockwiseBtn');
    const startGameBtn = document.getElementById('startGameBtn');
    const rulesBtn = document.getElementById('rulesBtn');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const winnerMessage = document.getElementById('winnerMessage');
    const finalScore = document.getElementById('finalScore');
    const restartBtn = document.getElementById('restartBtn');

    // 在 rpsContainer 后插入难度选择
    document.getElementById('rpsContainer').insertAdjacentHTML('afterend', difficultyHTML);

    // ++++new
    // 添加CSS样式
    const difficultyCSS = `
.difficulty-container {
    text-align: center;
    margin-bottom: 20px;
}

.difficulty-options {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-top: 15px;
}

.difficulty-option {
    padding: 10px 20px;
    border-radius: 5px;
    border: 2px solid #3498db;
    background-color: white;
    cursor: pointer;
    transition: all 0.2s;
}

.difficulty-option:hover {
    background-color: #ecf0f1;
    transform: scale(1.05);
}

.difficulty-option.selected {
    background-color: #3498db;
    color: white;
    font-weight: bold;
}

/* 添加难度显示样式 */
.difficulty-display {
    text-align: center;
    margin-bottom: 15px;
}

.difficulty-badge {
    display: inline-block;
    padding: 5px 12px;
    background-color: #3498db;
    color: white;
    border-radius: 15px;
    font-weight: bold;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
`;
    const difficultyOptions = document.querySelectorAll('.difficulty-option');
    const difficultyContainer = document.getElementById('difficultyContainer');
    const difficultyDisplay = document.getElementById('difficultyDisplay');
    const currentDifficultySpan = document.getElementById('currentDifficulty');
    // ++++new
    // 添加难度选择事件监听和元素引用
    function initDifficultySelection() {


        difficultyOptions.forEach(option => {
            option.addEventListener('click', () => {
                // 移除之前的选择
                difficultyOptions.forEach(opt => opt.classList.remove('selected'));
                // 添加新选择
                option.classList.add('selected');
                // 设置难度
                gameState.aiDifficulty = parseInt(option.dataset.difficulty);
                // 更新显示的难度文本
                currentDifficultySpan.textContent = getDifficultyName(gameState.aiDifficulty);
                console.log(`AI难度设置为: ${getDifficultyName(gameState.aiDifficulty)}`);
            });
        });
    }
    // 添加样式到头部
    const styleElement = document.createElement('style');
    styleElement.textContent = difficultyCSS;
    document.head.appendChild(styleElement);
    // 获取难度名称
    function getDifficultyName(difficulty) {
        switch(difficulty) {
            case 0: return "简单";
            case 1: return "中等";
            case 2: return "困难";
            default: return "未知";
        }
    }

    // 初始化游戏
    // !!!!update
    // 修改 initGame 函数，初始化难度选择
    function initGame() {
        renderBoard();
        updateScores();
        updateGameStatus('请通过石头剪子布决定先手');

        // 添加事件监听器
        rpsOptions.forEach(option => {
            option.addEventListener('click', handleRPSChoice);
        });

        clockwiseBtn.addEventListener('click', () => handleDirectionChoice(true));
        counterClockwiseBtn.addEventListener('click', () => handleDirectionChoice(false));

        startGameBtn.addEventListener('click', startGame);
        rulesBtn.addEventListener('click', showRules);
        restartBtn.addEventListener('click', restartGame);

        // 初始化难度选择
        initDifficultySelection();

        // 添加格子点击事件
        for (let i = 0; i < NUM_PITS; i++) {
            document.getElementById(`player-${i}`).addEventListener('click', () => handlePitClick(i));
        }
    }

    // 渲染游戏棋盘
    // !!!!update
    // 修改 renderBoard 函数，添加石子自适应缩放
    function renderBoard() {
        // 清空棋盘
        for (let player = 0; player < 2; player++) {
            const playerType = player === 0 ? 'player' : 'system';
            for (let pit = 0; pit < NUM_PITS; pit++) {
                const pitElement = document.getElementById(`${playerType}-${pit}`);

                // 保存原来的选中状态
                const wasSelected = pitElement.classList.contains('selected-pit');

                // 获取全局编号 (1-10)
                const globalPitIndex = player === 0 ? pit + 1 : pit + 6;

                // 清空内容
                pitElement.innerHTML = `<div class="pit-index">${globalPitIndex}</div>`;

                // 获取石子数量
                const stoneCount = gameState.board[player][pit];

                // 根据石子数量添加适当的类名
                pitElement.classList.remove('stones-1-4', 'stones-5-9', 'stones-10-16', 'stones-17+');

                if (stoneCount <= 4) {
                    pitElement.classList.add('stones-1-4');
                } else if (stoneCount <= 9) {
                    pitElement.classList.add('stones-5-9');
                } else if (stoneCount <= 16) {
                    pitElement.classList.add('stones-10-16');
                } else {
                    pitElement.classList.add('stones-17+');
                }

                // 添加石子
                for (let s = 0; s < stoneCount; s++) {
                    const stone = document.createElement('div');
                    stone.className = 'stone';
                    pitElement.appendChild(stone);
                }

                // 恢复选中状态（如果有）
                if (wasSelected) {
                    pitElement.classList.add('selected-pit');
                }
            }
        }

        // 设置可选择的格子
        updateSelectablePits();

        // 输出调试信息 - 格式化显示棋盘状态
        console.log("棋盘状态:");
        console.log("玩家格子(1-5):", gameState.board[0]);
        console.log("系统格子(6-10):", gameState.board[1]);
        console.log("玩家得分:", gameState.score[0], "系统得分:", gameState.score[1]);
    }

    // !!!!update
    // 修改 pit 样式为圆角矩形
    function updatePitStyles() {
        const styles = `
        .pit {
            width: 100px;
            height: 100px;
            border-radius: 16px; /* 改为圆角矩形 */
            background-color: #f0d9b5;
            border: 3px solid #b58863;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            padding: 5px;
            cursor: pointer;
            position: relative;
            overflow: hidden; /* 防止石子溢出 */
        }

        .pit.selectable:hover {
            background-color: #dcc194;
            transform: scale(1.05);
            transition: all 0.2s;
        }

        /* 根据石子数量缩放石子大小 */
        .pit.stones-1-4 .stone {
            width: 20px;
            height: 20px;
            margin: 5px;
        }

        .pit.stones-5-9 .stone {
            width: 16px;
            height: 16px;
            margin: 4px;
        }

        .pit.stones-10-16 .stone {
            width: 12px;
            height: 12px;
            margin: 3px;
        }

        .pit.stones-17+ .stone {
            width: 8px;
            height: 8px;
            margin: 2px;
        }

        /* 新的石子排列样式 */
        .pit {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(20px, 1fr));
            grid-auto-rows: min-content;
            gap: 5px;
        }

        .pit.stones-5-9 {
            grid-template-columns: repeat(auto-fill, minmax(16px, 1fr));
            gap: 4px;
        }

        .pit.stones-10-16 {
            grid-template-columns: repeat(auto-fill, minmax(12px, 1fr));
            gap: 3px;
        }

        .pit.stones-17\\+ {
            grid-template-columns: repeat(auto-fill, minmax(8px, 1fr));
            gap: 2px;
        }
    `;

        // 检查是否已存在样式
        const existingStyle = document.getElementById('pit-custom-styles');
        if (existingStyle) {
            existingStyle.remove();
        }

        // 添加新样式
        const styleElement = document.createElement('style');
        styleElement.id = 'pit-custom-styles';
        styleElement.textContent = styles;
        document.head.appendChild(styleElement);
    }

    // 更新可选择的格子
    function updateSelectablePits() {
        // 移除所有格子的可选择状态
        for (let i = 0; i < NUM_PITS; i++) {
            document.getElementById(`player-${i}`).classList.remove('selectable');
            document.getElementById(`system-${i}`).classList.remove('selectable');
        }

        // 如果游戏未开始或正在动画中，不更新
        if (!gameState.gameStarted || gameState.gameOver || gameState.isAnimating) {
            return;
        }

        // 只有轮到玩家时才设置可选择的格子
        if (gameState.currentPlayer === 0) {
            for (let i = 0; i < NUM_PITS; i++) {
                if (gameState.board[0][i] > 0) {
                    document.getElementById(`player-${i}`).classList.add('selectable');
                }
            }
        }
    }

    // 更新分数显示
    function updateScores() {
        playerScore.textContent = gameState.score[0];
        systemScore.textContent = gameState.score[1];
    }

    // 更新游戏状态显示
    function updateGameStatus(message) {
        gameStatus.textContent = message;
    }

    // 处理石头剪子布选择
    function handleRPSChoice(event) {
        const playerChoice = event.target.dataset.choice;
        const choices = ['石头', '剪子', '布'];
        const systemChoice = choices[Math.floor(Math.random() * 3)];

        rpsResult.textContent = `玩家选择了 ${playerChoice}，系统选择了 ${systemChoice}`;

        setTimeout(() => {
            if (playerChoice === systemChoice) {
                rpsResult.textContent = '平局！请重新选择。';
            } else if (
                (playerChoice === '石头' && systemChoice === '剪子') ||
                (playerChoice === '剪子' && systemChoice === '布') ||
                (playerChoice === '布' && systemChoice === '石头')
            ) {
                rpsResult.textContent = '玩家赢了！玩家先手。';
                gameState.currentPlayer = 0;
                finishRPS();
            } else {
                rpsResult.textContent = '系统赢了！系统先手。';
                gameState.currentPlayer = 1;
                finishRPS();
            }
        }, 1000);
    }

    // !!!!update
    // 修改 finishRPS 函数，在石头剪子布后隐藏难度选择，显示难度标签和开始游戏按钮
    function finishRPS() {
        setTimeout(() => {
            // 隐藏石头剪子布和难度选择
            rpsContainer.style.display = 'none';
            difficultyContainer.style.display = 'none';

            // 显示当前AI难度标签
            difficultyDisplay.style.display = 'block';
            currentDifficultySpan.textContent = getDifficultyName(gameState.aiDifficulty);

            // 显示游戏状态
            updateGameStatus(`${gameState.currentPlayer === 0 ? '玩家' : '系统'}先手`);

            // 显示开始游戏按钮
            startGameBtn.style.display = 'block';
        }, 1500);
    }

    // 开始游戏
    function startGame() {
        gameState.gameStarted = true;
        startGameBtn.style.display = 'none';

        if (gameState.currentPlayer === 0) {
            updateGameStatus('玩家回合，请选择一个格子');
        } else {
            updateGameStatus('系统回合，系统正在思考...');
            setTimeout(systemTurn, 1000);
        }

        updateSelectablePits();
    }

    // 处理格子点击
    function handlePitClick(pitIndex) {
        // 检查是否可以点击
        if (!gameState.gameStarted || gameState.gameOver || gameState.isAnimating ||
            gameState.currentPlayer !== 0 || gameState.board[0][pitIndex] === 0) {
            return;
        }

        // 标记选中的格子
        gameState.selectedPit = pitIndex;
        document.getElementById(`player-${pitIndex}`).classList.add('selected-pit');

        // 显示方向选择按钮
        directionButtons.style.display = 'flex';
        updateGameStatus('请选择播种方向');
    }

    // 处理方向选择
    function handleDirectionChoice(clockwise) {
        // 隐藏方向按钮
        directionButtons.style.display = 'none';

        // 移除选中格子的高亮
        if (gameState.selectedPit !== null) {
            document.getElementById(`player-${gameState.selectedPit}`).classList.remove('selected-pit');
        }

        // 全局编号 (1-5)
        const globalPitIndex = gameState.selectedPit + 1;

        // 记录玩家操作
        console.log("------ 玩家操作 ------");
        console.log(`玩家选择了格子 ${globalPitIndex}，方向：${clockwise ? '顺时针' : '逆时针'}`);

        // 执行玩家移动
        makeMove(0, gameState.selectedPit, clockwise);
    }

    // 系统回合
    // !!!!update
    // 修改系统回合，添加对格子为空的检查
    // 修改系统回合函数，根据难度选择不同策略
    // !!!!update
    // 修改系统回合函数，根据难度选择不同策略
    function systemTurn() {
        if (gameState.gameOver) return;

        updateGameStatus('系统回合，系统正在行动...');

        // 检查是否有有效的格子
        const validPits = [];
        for (let i = 0; i < NUM_PITS; i++) {
            if (gameState.board[1][i] > 0) {
                validPits.push(i);
            }
        }

        // 如果没有有效的格子，结束回合
        if (validPits.length === 0) {
            console.log("系统没有石子可操作，跳过回合");
            updateGameStatus("系统没有石子可操作，跳过回合");

            setTimeout(() => {
                endTurn();
            }, 1500);

            return;
        }

        // 根据难度选择AI策略
        let selectedPit, clockwise;

        switch(gameState.aiDifficulty) {
            case 0: // 简单难度 - 完全随机
                selectedPit = validPits[Math.floor(Math.random() * validPits.length)];
                clockwise = Math.random() > 0.5;
                break;

            case 1: // 中等难度 - 寻找立即捕获
                const mediumAIMove = findMediumAIMove(validPits);
                selectedPit = mediumAIMove.pit;
                clockwise = mediumAIMove.clockwise;
                break;

            case 2: // 困难难度 - 评估函数
                const hardAIMove = findHardAIMove(validPits);
                selectedPit = hardAIMove.pit;
                clockwise = hardAIMove.clockwise;
                break;

            default: // 默认使用中等难度
                const defaultMove = findMediumAIMove(validPits);
                selectedPit = defaultMove.pit;
                clockwise = defaultMove.clockwise;
        }

        // 高亮显示系统选择的格子
        const pitElement = document.getElementById(`system-${selectedPit}`);
        pitElement.classList.add('selected-pit');

        // 记录系统操作
        console.log("------ 系统操作 ------");
        console.log(`系统选择了格子 ${selectedPit + 6}，方向：${clockwise ? '顺时针' : '逆时针'}`);
        console.log(`AI难度: ${getDifficultyName(gameState.aiDifficulty)}`);

        setTimeout(() => {
            pitElement.classList.remove('selected-pit');
            updateGameStatus(`系统选择了格子 ${selectedPit + 6}，方向：${clockwise ? '顺时针' : '逆时针'}`);

            // 执行系统移动
            makeMove(1, selectedPit, clockwise);
        }, 1000);
    }
    // 中等难度AI - 寻找立即能捕获的移动
    // ++++new
    // 中等难度AI - 寻找立即能捕获的移动
    function findMediumAIMove(validPits) {
        // 尝试找到一个能立即捕获的移动
        for (let pit of validPits) {
            // 尝试顺时针
            if (canCapture(1, pit, true)) {
                return { pit: pit, clockwise: true };
            }

            // 尝试逆时针
            if (canCapture(1, pit, false)) {
                return { pit: pit, clockwise: false };
            }
        }

        // 如果没有找到能立即捕获的移动，优先选择石子多的格子
        // 按石子数量降序排序
        const sortedPits = [...validPits].sort((a, b) => gameState.board[1][b] - gameState.board[1][a]);

        // 选择石子最多的格子，方向随机
        return {
            pit: sortedPits[0],
            clockwise: Math.random() > 0.5
        };
    }

    // ++++new
    // 困难难度AI - 使用评估函数
    function findHardAIMove(validPits) {
        let bestScore = -Infinity;
        let bestPit = validPits[0];
        let bestDirection = true;

        // 对每个可能的移动进行评估
        for (let pit of validPits) {
            // 评估顺时针移动
            const clockwiseScore = evaluateMove(1, pit, true);
            if (clockwiseScore > bestScore) {
                bestScore = clockwiseScore;
                bestPit = pit;
                bestDirection = true;
            }

            // 评估逆时针移动
            const counterClockwiseScore = evaluateMove(1, pit, false);
            if (counterClockwiseScore > bestScore) {
                bestScore = counterClockwiseScore;
                bestPit = pit;
                bestDirection = false;
            }
        }

        return { pit: bestPit, clockwise: bestDirection };
    }

    // ++++new
    // 检查移动是否能立即捕获
    function canCapture(player, pitIndex, clockwise) {
        // 创建一个游戏状态的深拷贝用于模拟
        const simulationState = {
            board: [
                [...gameState.board[0]],
                [...gameState.board[1]]
            ],
            score: [...gameState.score]
        };

        // 获取格子中的石子数
        const stones = simulationState.board[player][pitIndex];
        if (stones === 0) return false;

        // 从格子中取出所有石子
        simulationState.board[player][pitIndex] = 0;

        // 创建棋盘映射
        const boardMap = createBoardMap();

        // 找到当前位置在映射中的索引
        let currentPosition = findPositionInMap(boardMap, player, pitIndex);

        // 按照选择的方向分发石子
        for (let i = 0; i < stones; i++) {
            // 移动到下一个位置
            if (clockwise) {
                currentPosition = (currentPosition + 1) % boardMap.length;
            } else {
                currentPosition = (currentPosition - 1 + boardMap.length) % boardMap.length;
            }

            // 获取当前位置的玩家和格子
            const [nextPlayer, nextPit] = boardMap[currentPosition];

            // 放置石子
            simulationState.board[nextPlayer][nextPit]++;
        }

        // 获取最后一个石子的位置
        const [lastPlayer, lastPit] = boardMap[currentPosition];

        // 如果最后一个石子放在一个空格子中，检查下一个格子是否有石子可以捕获
        if (simulationState.board[lastPlayer][lastPit] === 1) {
            // 确定下一个格子的位置
            let nextPosition;
            if (clockwise) {
                nextPosition = (currentPosition + 1) % boardMap.length;
            } else {
                nextPosition = (currentPosition - 1 + boardMap.length) % boardMap.length;
            }

            // 获取下一个格子的玩家和索引
            const [nextPlayer, nextPit] = boardMap[nextPosition];

            // 如果下一个格子有石子，就可以捕获
            return simulationState.board[nextPlayer][nextPit] > 0;
        }

        return false;
    }


    // ++++new
    // 评估移动的分数
    function evaluateMove(player, pitIndex, clockwise) {
        // 创建一个游戏状态的深拷贝用于模拟
        const simulationState = {
            board: [
                [...gameState.board[0]],
                [...gameState.board[1]]
            ],
            score: [...gameState.score]
        };

        // 模拟执行移动
        const scoreChange = simulateMove(simulationState, player, pitIndex, clockwise);

        // 计算移动后我方和对方的石子总数
        let myTotalStones = 0;
        let opponentTotalStones = 0;

        for (let i = 0; i < NUM_PITS; i++) {
            myTotalStones += simulationState.board[player][i];
            opponentTotalStones += simulationState.board[1-player][i];
        }

        // 评估函数组成部分:
        // 1. 直接得分增益 (最重要)
        const scoreGain = scoreChange * 10;

        // 2. 我方石子总数 (石子越多，未来可能有更多移动选择)
        const myStonesFactor = myTotalStones * 0.5;

        // 3. 对手石子数量 (对手石子越少越好)
        const opponentStonesFactor = (40 - opponentTotalStones) * 0.3;

        // 4. 格子中石子的分布 (避免集中在少数几个格子)
        let distribution = 0;
        let nonEmptyPits = 0;

        for (let i = 0; i < NUM_PITS; i++) {
            if (simulationState.board[player][i] > 0) {
                nonEmptyPits++;
                // 惩罚单个格子中石子过多的情况
                if (simulationState.board[player][i] > 8) {
                    distribution -= (simulationState.board[player][i] - 8) * 0.2;
                }
            }
        }

        // 奖励石子分布在更多格子中
        distribution += nonEmptyPits * 2;

        // 组合所有因素
        return scoreGain + myStonesFactor + opponentStonesFactor + distribution;
    }

    // ++++new
    // 模拟移动并返回分数变化
    function simulateMove(state, player, pitIndex, clockwise) {
        const initialScore = state.score[player];

        // 获取格子中的石子数
        let stones = state.board[player][pitIndex];
        if (stones === 0) return 0;

        // 从格子中取出所有石子
        state.board[player][pitIndex] = 0;

        // 创建棋盘映射
        const boardMap = createBoardMap();

        // 找到当前位置在映射中的索引
        let currentPosition = findPositionInMap(boardMap, player, pitIndex);

        // 继续分发石子直到没有石子可分发
        while (stones > 0) {
            // 按照选择的方向移动到下一个位置
            if (clockwise) {
                currentPosition = (currentPosition + 1) % boardMap.length;
            } else {
                currentPosition = (currentPosition - 1 + boardMap.length) % boardMap.length;
            }

            // 获取当前位置的玩家和格子
            const [nextPlayer, nextPit] = boardMap[currentPosition];

            // 放置石子
            state.board[nextPlayer][nextPit]++;
            stones--;

            // 如果这是最后一个石子且放在空格子中
            if (stones === 0 && state.board[nextPlayer][nextPit] === 1) {
                // 确定下一个格子的位置
                let capturePosition;
                if (clockwise) {
                    capturePosition = (currentPosition + 1) % boardMap.length;
                } else {
                    capturePosition = (currentPosition - 1 + boardMap.length) % boardMap.length;
                }

                // 获取捕获格子的玩家和索引
                const [capturePlayer, capturePit] = boardMap[capturePosition];

                // 如果下一个格子有石子，捕获它们
                if (state.board[capturePlayer][capturePit] > 0) {
                    const capturedStones = state.board[capturePlayer][capturePit];
                    state.board[capturePlayer][capturePit] = 0;
                    state.score[player] += capturedStones;
                }
            }
            // 如果最后一个石子放在非空格子中，拿起这些石子继续分发
            else if (stones === 0 && state.board[nextPlayer][nextPit] > 1) {
                stones = state.board[nextPlayer][nextPit];
                state.board[nextPlayer][nextPit] = 0;
            }
        }

        // 返回分数变化
        return state.score[player] - initialScore;
    }
    // 创建正确的棋盘映射 - 按照物理上的顺时针顺序排列
    function createBoardMap() {
        // 按照正确的物理顺时针顺序排列：1-6-7-8-9-10-5-4-3-2
        return [
            [0, 0], // 格子1
            [1, 0], // 格子6
            [1, 1], // 格子7
            [1, 2], // 格子8
            [1, 3], // 格子9
            [1, 4], // 格子10
            [0, 4], // 格子5
            [0, 3], // 格子4
            [0, 2], // 格子3
            [0, 1], // 格子2
        ];
    }

    // 在映射中查找位置 - 保持不变
    function findPositionInMap(boardMap, player, pit) {
        for (let i = 0; i < boardMap.length; i++) {
            if (boardMap[i][0] === player && boardMap[i][1] === pit) {
                return i;
            }
        }
        return -1;
    }

    // ++++new
    // 创建一个容器来存放要分配的石子
    // !!!!update
    // 创建一个容器来存放要分配的石子 - 修复移除问题
    function createDistributionContainer() {
        // 检查是否已经存在
        let container = document.getElementById('distribution-container');
        if (container) {
            // 完全删除现有容器并创建新的，避免残留问题
            container.remove();
        }

        // 创建新容器
        container = document.createElement('div');
        container.id = 'distribution-container';
        container.className = 'distribution-container';
        document.body.appendChild(container);

        return container;
    }
    // ++++new
    // 添加分配容器样式
    // ++++new
    // 添加改进的分配容器样式，确保石子正确显示
    function addDistributionStyles() {
        const styles = `
        .distribution-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 2px solid #3498db;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            max-width: 80%;
            justify-content: center;
            z-index: 1000;
            min-height: 50px; /* 确保即使没有石子也有高度 */
        }

        .distribution-stone {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #333;
            margin: 5px;
            display: inline-block; /* 确保石子正确显示 */
        }

        .distribution-stone.distributing {
            animation: pulse-stone 1s infinite;
        }

        @keyframes pulse-stone {
            0% { transform: scale(1); background-color: #333; }
            50% { transform: scale(1.2); background-color: #e74c3c; }
            100% { transform: scale(1); background-color: #333; }
        }

        .active-distribution-pit {
            box-shadow: 0 0 0 4px rgba(46, 204, 113, 0.8);
            animation: active-pulse 1.5s infinite;
        }

        @keyframes active-pulse {
            0% { box-shadow: 0 0 0 4px rgba(46, 204, 113, 0.8); }
            50% { box-shadow: 0 0 0 8px rgba(46, 204, 113, 0.4); }
            100% { box-shadow: 0 0 0 4px rgba(46, 204, 113, 0.8); }
        }

        .next-distribution-pit {
            box-shadow: 0 0 0 4px rgba(241, 196, 15, 0.8);
            animation: next-pulse 1.5s infinite;
        }

        @keyframes next-pulse {
            0% { box-shadow: 0 0 0 4px rgba(241, 196, 15, 0.8); }
            50% { box-shadow: 0 0 0 8px rgba(241, 196, 15, 0.4); }
            100% { box-shadow: 0 0 0 4px rgba(241, 196, 15, 0.8); }
        }

        .moving-stone {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #333;
            z-index: 1001; /* 确保在最上层 */
            transition: all 0.5s ease;
        }
    `;

        // 移除旧样式以避免重复
        const existingStyle = document.getElementById('distribution-styles');
        if (existingStyle) {
            existingStyle.remove();
        }

        const styleElement = document.createElement('style');
        styleElement.id = 'distribution-styles';
        styleElement.textContent = styles;
        document.head.appendChild(styleElement);
    }
    // ++++new
    // 更新分配容器中的石子样式
    function updateDistributionStoneStyles() {
        const styles = `
        .distribution-stone {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin: 5px;
            display: inline-block;
            transition: all 0.3s ease;
        }

        .distribution-stone:nth-child(3n+1) {
            background-color: #333; /* 黑色 */
        }

        .distribution-stone:nth-child(3n+2) {
            background-color: #e74c3c; /* 红色 */
        }

        .distribution-stone:nth-child(3n) {
            background-color: #3498db; /* 蓝色 */
        }

        .distribution-stone.distributing {
            animation: pulse-stone 1s infinite;
            transform: scale(1.2);
            z-index: 10;
            box-shadow: 0 0 8px rgba(255, 255, 0, 0.8);
        }

        @keyframes pulse-stone {
            0% { transform: scale(1.2); box-shadow: 0 0 8px rgba(255, 255, 0, 0.8); }
            50% { transform: scale(1.4); box-shadow: 0 0 12px rgba(255, 255, 0, 1); }
            100% { transform: scale(1.2); box-shadow: 0 0 8px rgba(255, 255, 0, 0.8); }
        }
    `;

        // 检查是否已存在样式
        const existingStyle = document.getElementById('distribution-stone-styles');
        if (existingStyle) {
            existingStyle.remove();
        }

        // 添加新样式
        const styleElement = document.createElement('style');
        styleElement.id = 'distribution-stone-styles';
        styleElement.textContent = styles;
        document.head.appendChild(styleElement);
    }

    // !!!!update
    // 修改 stone 样式
    function updateStoneStyles() {
        const styles = `
        .stone {
            border-radius: 50%;
            background-color: #333;
            transition: all 0.3s ease;
        }

        /* 添加多种颜色的石子，使其更有辨识度 */
        .stone:nth-child(3n+1) {
            background-color: #333; /* 黑色 */
        }

        .stone:nth-child(3n+2) {
            background-color: #e74c3c; /* 红色 */
        }

        .stone:nth-child(3n) {
            background-color: #3498db; /* 蓝色 */
        }

        /* 移动中的石子也应用相同的样式 */
        .moving-stone {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #333;
            z-index: 1001;
            transition: all 0.5s ease;
        }

        .moving-stone:nth-child(3n+2) {
            background-color: #e74c3c;
        }

        .moving-stone:nth-child(3n) {
            background-color: #3498db;
        }
    `;

        // 检查是否已存在样式
        const existingStyle = document.getElementById('stone-custom-styles');
        if (existingStyle) {
            existingStyle.remove();
        }

        // 添加新样式
        const styleElement = document.createElement('style');
        styleElement.id = 'stone-custom-styles';
        styleElement.textContent = styles;
        document.head.appendChild(styleElement);
    }

    // ++++new
    // 增强的石子分配动画
    // 修复动画同步和石子分配容器的问题

    // !!!!update
    // 增强的石子分配动画 - 修复同步问题
    // !!!!update
    // 修改 enhancedAnimateMove 函数，使石子颜色与分配容器中的石子颜色保持一致
    // !!!!update
    // 修复分配容器更新问题
    function enhancedAnimateMove(animationQueue, index, originalPlayer, originalPit, clockwise, nextPlayer, nextPit, distributingPlayer = null) {
        // distributingPlayer参数是真正在分配石子的玩家
        const actualPlayer = distributingPlayer !== null ? distributingPlayer : originalPlayer;

        if (index >= animationQueue.length) {
            // 立即移除分配容器，确保不留下任何残余
            const container = document.getElementById('distribution-container');
            if (container) {
                container.innerHTML = ''; // 先清空内容
                document.body.removeChild(container);
            }

            // 移除所有特殊高亮
            const allPits = document.querySelectorAll('.pit');
            allPits.forEach(pit => {
                pit.classList.remove('active-distribution-pit');
                pit.classList.remove('next-distribution-pit');
            });

            // 动画完成，检查是否需要继续分发或捕获
            finishMove(actualPlayer, originalPit, clockwise, nextPlayer, nextPit);
            return;
        }

        // 获取分配容器中的石子
        const container = document.getElementById('distribution-container');
        if (!container) return; // 安全检查

        // 强制更新 - 确保石子数量与index相符
        // 删除所有石子，然后重新创建正确数量的石子
        container.innerHTML = '';

        // 重新创建剩余的石子（动画队列中从当前index开始的石子）
        for (let i = index; i < animationQueue.length; i++) {
            const stone = document.createElement('div');
            stone.className = 'distribution-stone';

            // 根据索引设置石子颜色
            const colorIndex = (i % 3) + 1;
            if (colorIndex === 1) {
                stone.style.backgroundColor = '#333'; // 黑色
            } else if (colorIndex === 2) {
                stone.style.backgroundColor = '#e74c3c'; // 红色
            } else {
                stone.style.backgroundColor = '#3498db'; // 蓝色
            }

            if (i === index) {
                stone.classList.add('distributing'); // 标记当前要分配的石子
            }

            container.appendChild(stone);
        }

        // 获取当前要分配的石子
        const distributingStone = container.querySelector('.distributing');

        const action = animationQueue[index];
        const playerType = action.player === 0 ? 'player' : 'system';
        const pitElement = document.getElementById(`${playerType}-${action.pit}`);

        // 移除所有格子的临时高亮
        const allPits = document.querySelectorAll('.pit');
        allPits.forEach(pit => {
            pit.classList.remove('selected-pit');
            pit.classList.remove('next-distribution-pit');
        });

        // 保持当前活动格子的高亮
        const originalPlayerType = originalPlayer === 0 ? 'player' : 'system';
        const originalPitElement = document.getElementById(`${originalPlayerType}-${originalPit}`);
        if (originalPitElement) {
            originalPitElement.classList.add('active-distribution-pit');
        }

        // 高亮当前正在接收石子的格子
        pitElement.classList.add('selected-pit');

        // 准备下一个石子的高亮 - 但现在先不添加，等当前动画结束后再添加
        let nextElement = null;
        if (index + 1 < animationQueue.length) {
            const nextAction = animationQueue[index + 1];
            const nextType = nextAction.player === 0 ? 'player' : 'system';
            nextElement = document.getElementById(`${nextType}-${nextAction.pit}`);
        }

        // 创建移动的石子动画
        const stone = document.createElement('div');
        stone.className = 'moving-stone';

        // 使移动中的石子保持与分配容器中石子相同的颜色
        const colorIndex = (index % 3) + 1;
        if (colorIndex === 1) {
            stone.style.backgroundColor = '#333'; // 黑色
        } else if (colorIndex === 2) {
            stone.style.backgroundColor = '#e74c3c'; // 红色
        } else {
            stone.style.backgroundColor = '#3498db'; // 蓝色
        }

        document.body.appendChild(stone);

        // 获取起始位置（分配容器中的石子）
        const stoneRect = distributingStone ? distributingStone.getBoundingClientRect() : container.getBoundingClientRect();

        // 获取目标位置
        const targetRect = pitElement.getBoundingClientRect();

        // 设置起始位置
        stone.style.left = `${stoneRect.left}px`;
        stone.style.top = `${stoneRect.top}px`;

        // 更新状态显示
        if (action.globalPitIndex) {
            updateGameStatus(`正在向格子 ${action.globalPitIndex} 放置石子...`);
        }

        // 触发石子移动动画
        setTimeout(() => {
            stone.style.left = `${targetRect.left + targetRect.width / 2 - 10}px`;
            stone.style.top = `${targetRect.top + targetRect.height / 2 - 10}px`;
        }, 50);

        // 石子到达目标后
        setTimeout(() => {
            // 移除移动中的石子
            if (document.body.contains(stone)) {
                document.body.removeChild(stone);
            }

            // 更新游戏状态
            gameState.board[action.player][action.pit]++;

            // 更新棋盘显示
            renderBoard();

            // 在当前石子完成移动后，添加下一个要高亮的格子
            if (nextElement) {
                nextElement.classList.add('next-distribution-pit');
            }

            // 继续下一个动画
            setTimeout(() => {
                enhancedAnimateMove(animationQueue, index + 1, originalPlayer, originalPit, clockwise, nextPlayer, nextPit, actualPlayer);
            }, 500);
        }, 500);
    }

    // !!!!update
    // 更新 makeMove 函数中的移动逻辑
    // 注意：逻辑相反了，顺时针应该是增加索引，逆时针是减少索引
    // !!!!update
    // 修改makeMove函数，增强视觉效果
    function makeMove(player, pitIndex, clockwise) {
        gameState.isAnimating = true;

        // 创建棋盘映射
        const boardMap = createBoardMap();

        // 在映射中找到当前位置
        let currentPosition = findPositionInMap(boardMap, player, pitIndex);

        // 全局格子索引，用于日志
        const globalPitIndex = player === 0 ? pitIndex + 1 : pitIndex + 6;

        console.log(`开始移动: ${player === 0 ? "玩家" : "系统"} 格子${globalPitIndex}`);

        // 复制当前棋盘状态用于日志记录（如果有实现日志功能）
        const boardStateBefore = typeof cloneBoardState === 'function' ? cloneBoardState(gameState.board) : null;

        // 从起始格子拿取石子
        let stones = gameState.board[player][pitIndex];
        gameState.board[player][pitIndex] = 0;
        console.log(`拿起 ${stones} 个石子`);

        // 记录操作日志（如果有实现日志功能）
        if (typeof logMoveStart === 'function') {
            logMoveStart(player, pitIndex, stones);
        }

        // 渲染棋盘以显示拿起石子后的状态
        renderBoard();

        // 高亮当前操作的格子
        const playerType = player === 0 ? 'player' : 'system';
        const pitElement = document.getElementById(`${playerType}-${pitIndex}`);

        // 移除所有格子的高亮
        const allPits = document.querySelectorAll('.pit');
        allPits.forEach(pit => {
            pit.classList.remove('selected-pit');
            pit.classList.remove('active-distribution-pit');
            pit.classList.remove('next-distribution-pit');
        });

        // 高亮当前操作的格子
        pitElement.classList.add('active-distribution-pit');

        // 创建分配容器并显示要分配的石子
        const distributionContainer = createDistributionContainer();

        // 添加石子到分配容器
        for (let i = 0; i < stones; i++) {
            const stone = document.createElement('div');
            stone.className = 'distribution-stone';
            if (i === 0) {
                stone.classList.add('distributing'); // 标记第一个要分配的石子
            }
            distributionContainer.appendChild(stone);
        }

        // 确定下一个要分配的格子
        let nextPosition = currentPosition;
        if (clockwise) {
            nextPosition = (nextPosition + 1) % boardMap.length;
        } else {
            nextPosition = (nextPosition - 1 + boardMap.length) % boardMap.length;
        }

        const [nextPlayer, nextPit] = boardMap[nextPosition];
        const nextPlayerType = nextPlayer === 0 ? 'player' : 'system';
        const nextPitElement = document.getElementById(`${nextPlayerType}-${nextPit}`);

        // 高亮下一个要分配的格子
        nextPitElement.classList.add('next-distribution-pit');

        // 更新游戏状态
        updateGameStatus(`${player === 0 ? '玩家' : '系统'} 拿起了格子 ${globalPitIndex} 的 ${stones} 个石子，准备分配...`);

        // 创建动画队列
        const animationQueue = [];

        // 分发石子
        while (stones > 0) {
            // 基于方向移动到下一个位置
            if (clockwise) {
                currentPosition = (currentPosition + 1) % boardMap.length; // 顺时针增加索引
            } else {
                currentPosition = (currentPosition - 1 + boardMap.length) % boardMap.length; // 逆时针减少索引
            }

            // 获取新位置的玩家和格子
            const [nextPlayer, nextPit] = boardMap[currentPosition];

            // 全局格子索引用于显示
            const nextGlobalPitIndex = nextPlayer === 0 ? nextPit + 1 : nextPit + 6;

            // 添加到动画队列
            animationQueue.push({
                player: nextPlayer,
                pit: nextPit,
                globalPitIndex: nextGlobalPitIndex
            });

            stones--;
        }

        // 获取最后放置石子的格子
        const lastPosition = currentPosition;
        const [lastPlayer, lastPit] = boardMap[lastPosition];
        const lastGlobalPitIndex = lastPlayer === 0 ? lastPit + 1 : lastPit + 6;

        // 确定下一个位置，用于检查捕获或继续分发
        let nextCheckPosition;
        if (clockwise) {
            nextCheckPosition = (lastPosition + 1) % boardMap.length; // 顺时针增加索引
        } else {
            nextCheckPosition = (lastPosition - 1 + boardMap.length) % boardMap.length; // 逆时针减少索引
        }

        const [checkPlayer, checkPit] = boardMap[nextCheckPosition];
        const checkGlobalPitIndex = checkPlayer === 0 ? checkPit + 1 : checkPit + 6;

        console.log(`最后一个石子放在: 格子${lastGlobalPitIndex}`);
        console.log(`下一个格子是: 格子${checkGlobalPitIndex}`);

        // 短暂延迟后开始逐个分配石子
        setTimeout(() => {
            // 执行动画
            enhancedAnimateMove(animationQueue, 0, player, pitIndex, clockwise, checkPlayer, checkPit);
        }, 1000);
    }

    // 动画播种石子
    // Updated animateMove function
    // !!!!update
    // 修改animateMove函数，添加originalPlayer参数
    function animateMove(animationQueue, index, originalPlayer, originalPit, clockwise, nextPlayer, nextPit, distributingPlayer = null) {
        // distributingPlayer参数是真正在分配石子的玩家（通常是回合开始的玩家）
        // 如果没有提供，则使用originalPlayer
        const actualPlayer = distributingPlayer !== null ? distributingPlayer : originalPlayer;

        if (index >= animationQueue.length) {
            // 动画完成，检查是否需要继续分发或捕获
            finishMove(actualPlayer, originalPit, clockwise, nextPlayer, nextPit);
            return;
        }

        const action = animationQueue[index];
        const playerType = action.player === 0 ? 'player' : 'system';
        const pitElement = document.getElementById(`${playerType}-${action.pit}`);

        // 高亮当前格子
        const allPits = document.querySelectorAll('.pit');
        allPits.forEach(pit => pit.classList.remove('selected-pit'));
        pitElement.classList.add('selected-pit');

        // 创建移动的石子动画
        const stone = document.createElement('div');
        stone.className = 'moving-stone';
        document.body.appendChild(stone);

        // 获取起始位置（原始格子）
        const originalPlayerType = originalPlayer === 0 ? 'player' : 'system';
        const originalPitElement = document.getElementById(`${originalPlayerType}-${originalPit}`);
        const originalRect = originalPitElement.getBoundingClientRect();

        // 获取目标位置
        const targetRect = pitElement.getBoundingClientRect();

        // 设置起始位置
        stone.style.left = `${originalRect.left + originalRect.width / 2 - 10}px`;
        stone.style.top = `${originalRect.top + originalRect.height / 2 - 10}px`;

        // 触发动画
        setTimeout(() => {
            stone.style.left = `${targetRect.left + targetRect.width / 2 - 10}px`;
            stone.style.top = `${targetRect.top + targetRect.height / 2 - 10}px`;
        }, 50);

        // 更新状态显示
        if (action.globalPitIndex) {
            updateGameStatus(`正在向格子 ${action.globalPitIndex} 放置石子...`);
        }

        // 动画完成后
        setTimeout(() => {
            document.body.removeChild(stone);

            // 更新游戏状态
            gameState.board[action.player][action.pit]++;

            // 更新棋盘显示
            renderBoard();

            // 保持当前格子高亮
            pitElement.classList.add('selected-pit');

            // 继续下一个动画
            animateMove(animationQueue, index + 1, originalPlayer, originalPit, clockwise, nextPlayer, nextPit, actualPlayer);
        }, 500);
    }

    // ++++new
    // 新增函数，用于从当前格子开始分配石子
    // !!!!update
    // 修改startDistributionFromCurrentPit函数，使用增强的动画效果
    // !!!!update
    // startDistributionFromCurrentPit 函数，同样修复同步问题
    function startDistributionFromCurrentPit(originalPlayer, pitOwner, pitIndex, stones, clockwise) {
        // 创建棋盘映射
        const boardMap = createBoardMap();

        // 在映射中找到当前位置
        let currentPosition = findPositionInMap(boardMap, pitOwner, pitIndex);

        // 高亮当前操作的格子
        const playerType = pitOwner === 0 ? 'player' : 'system';
        const pitElement = document.getElementById(`${playerType}-${pitIndex}`);

        // 移除所有格子的高亮
        const allPits = document.querySelectorAll('.pit');
        allPits.forEach(pit => {
            pit.classList.remove('selected-pit');
            pit.classList.remove('active-distribution-pit');
            pit.classList.remove('next-distribution-pit');
        });

        // 高亮当前操作的格子
        pitElement.classList.add('active-distribution-pit');

        // 创建分配容器并显示要分配的石子 - 确保容器被完全重建
        const distributionContainer = createDistributionContainer();

        // 添加石子到分配容器
        for (let i = 0; i < stones; i++) {
            const stone = document.createElement('div');
            stone.className = 'distribution-stone';
            if (i === 0) {
                stone.classList.add('distributing'); // 标记第一个要分配的石子
            }
            distributionContainer.appendChild(stone);
        }

        // 确定下一个要分配的格子
        let nextPosition = currentPosition;
        if (clockwise) {
            nextPosition = (nextPosition + 1) % boardMap.length;
        } else {
            nextPosition = (nextPosition - 1 + boardMap.length) % boardMap.length;
        }

        const [nextDistPlayer, nextDistPit] = boardMap[nextPosition];
        const nextDistPlayerType = nextDistPlayer === 0 ? 'player' : 'system';
        const nextDistPitElement = document.getElementById(`${nextDistPlayerType}-${nextDistPit}`);

        // 高亮下一个要分配的格子
        nextDistPitElement.classList.add('next-distribution-pit');

        // 创建动画队列
        const animationQueue = [];

        // 分发石子
        while (stones > 0) {
            // 基于方向移动到下一个位置
            if (clockwise) {
                currentPosition = (currentPosition + 1) % boardMap.length; // 顺时针增加索引
            } else {
                currentPosition = (currentPosition - 1 + boardMap.length) % boardMap.length; // 逆时针减少索引
            }

            // 获取新位置的玩家和格子
            const [nextPlayer, nextPit] = boardMap[currentPosition];

            // 全局格子索引用于显示
            const nextGlobalPitIndex = nextPlayer === 0 ? nextPit + 1 : nextPit + 6;

            // 添加到动画队列
            animationQueue.push({
                player: nextPlayer,
                pit: nextPit,
                globalPitIndex: nextGlobalPitIndex
            });

            stones--;
        }

        // 获取最后放置石子的格子
        const lastPosition = currentPosition;
        const [lastPlayer, lastPit] = boardMap[lastPosition];
        const lastGlobalPitIndex = lastPlayer === 0 ? lastPit + 1 : lastPit + 6;

        // 确定下一个位置，用于检查捕获或继续分发
        let nextCheckPosition;
        if (clockwise) {
            nextCheckPosition = (lastPosition + 1) % boardMap.length; // 顺时针增加索引
        } else {
            nextCheckPosition = (lastPosition - 1 + boardMap.length) % boardMap.length; // 逆时针减少索引
        }

        const [checkPlayer, checkPit] = boardMap[nextCheckPosition];
        const checkGlobalPitIndex = checkPlayer === 0 ? checkPit + 1 : checkPit + 6;

        console.log(`最后一个石子放在: 格子${lastGlobalPitIndex}`);
        console.log(`下一个格子是: 格子${checkGlobalPitIndex}`);

        // 短暂延迟后开始逐个分配石子
        setTimeout(() => {
            // 执行动画
            enhancedAnimateMove(animationQueue, 0, pitOwner, pitIndex, clockwise, checkPlayer, checkPit, originalPlayer);
        }, 1000);
    }

    // !!!!update
    // 同样修正 finishMove 函数中的方向逻辑
    // !!!!update
    // !!!!update
    // 修改finishMove函数，确保从当前格子的下一个格子开始分配石子
    // !!!!update
    // 修改finishMove函数，使用增强的动画效果
    function finishMove(player, pitIndex, clockwise, nextPlayer, nextPit) {
        // 全局格子索引 (1-10)
        const nextGlobalPitIndex = nextPlayer === 0 ? nextPit + 1 : nextPit + 6;

        console.log(`完成播种，检查下一步操作`);

        // 创建棋盘映射
        const boardMap = createBoardMap();
        const currentPosition = findPositionInMap(boardMap, nextPlayer, nextPit);

        // 如果下一个格子为空
        if (gameState.board[nextPlayer][nextPit] === 0) {
            console.log(`下一个格子(${nextGlobalPitIndex})为空，检查捕获条件`);

            // 确定下下一个格子 - 修正逻辑
            let capturePosition;
            if (clockwise) {
                capturePosition = (currentPosition + 1) % boardMap.length; // 顺时针增加索引
            } else {
                capturePosition = (currentPosition - 1 + boardMap.length) % boardMap.length; // 逆时针减少索引
            }

            const [capturePlayer, capturePit] = boardMap[capturePosition];
            const captureGlobalPitIndex = capturePlayer === 0 ? capturePit + 1 : capturePit + 6;

            console.log(`下下一个格子是: 格子${captureGlobalPitIndex}`);

            // 捕获石子
            if (gameState.board[capturePlayer][capturePit] > 0) {
                const capturedStones = gameState.board[capturePlayer][capturePit];
                gameState.board[capturePlayer][capturePit] = 0;
                gameState.score[player] += capturedStones;

                console.log(`捕获了格子${captureGlobalPitIndex}的 ${capturedStones} 个石子！`);

                // 记录捕获日志（如果有实现日志功能）
                if (typeof logCapture === 'function') {
                    logCapture(player, capturePlayer, capturePit, capturedStones);
                }

                // 更新棋盘和分数
                renderBoard();
                updateScores();

                updateGameStatus(`${player === 0 ? '玩家' : '系统'}捕获了格子${captureGlobalPitIndex}的 ${capturedStones} 个石子！`);

                // 高亮显示被捕获的格子
                const captureType = capturePlayer === 0 ? 'player' : 'system';
                const capturePitElement = document.getElementById(`${captureType}-${capturePit}`);

                // 移除其他高亮
                const allPits = document.querySelectorAll('.pit');
                allPits.forEach(pit => {
                    pit.classList.remove('selected-pit');
                    pit.classList.remove('active-distribution-pit');
                    pit.classList.remove('next-distribution-pit');
                });

                // 高亮捕获的格子
                capturePitElement.classList.add('selected-pit');

                setTimeout(() => {
                    capturePitElement.classList.remove('selected-pit');
                    endTurn();
                }, 1000);
            } else {
                console.log(`没有可捕获的石子，回合结束`);
                // 更新棋盘和分数
                renderBoard();
                updateScores();
                endTurn();
            }
        } else {
            // 继续播种
            const stonesToPickUp = gameState.board[nextPlayer][nextPit];
            gameState.board[nextPlayer][nextPit] = 0;

            console.log(`继续拿起格子${nextGlobalPitIndex}的 ${stonesToPickUp} 个石子继续播种`);

            // 更新状态显示
            updateGameStatus(`${player === 0 ? '玩家' : '系统'}继续拿起格子 ${nextGlobalPitIndex} 的石子继续播种...`);

            // 高亮显示下一个要拿起的格子
            const nextPlayerType = nextPlayer === 0 ? 'player' : 'system';
            const nextPitElement = document.getElementById(`${nextPlayerType}-${nextPit}`);

            // 移除其他高亮
            const allPits = document.querySelectorAll('.pit');
            allPits.forEach(pit => {
                pit.classList.remove('selected-pit');
                pit.classList.remove('active-distribution-pit');
                pit.classList.remove('next-distribution-pit');
            });

            // 高亮下一个格子
            nextPitElement.classList.add('active-distribution-pit');

            // 更新棋盘显示
            renderBoard();

            setTimeout(() => {
                // 继续由原始玩家操作
                startDistributionFromCurrentPit(player, nextPlayer, nextPit, stonesToPickUp, clockwise);
            }, 1000);
        }
    }

    // ++++new
    // 初始化函数，添加新的样式
    function initEnhancedVisuals() {
        addDistributionStyles();
    }

    // 结束当前回合
    // !!!!update
    // 修复一方没有石子时的逻辑（在回合结束时检查）
    function endTurn() {
        gameState.isAnimating = false;
        gameState.moveCount++;

        console.log(`回合结束，总回合数: ${gameState.moveCount}`);
        console.log("------------------------");

        // 检查游戏是否结束
        if (checkGameOver()) {
            return;
        }

        // 切换玩家
        gameState.currentPlayer = (gameState.currentPlayer + 1) % 2;

        // 检查下一个玩家是否还有石子可以操作
        let nextPlayerHasStones = false;
        for (let i = 0; i < NUM_PITS; i++) {
            if (gameState.board[gameState.currentPlayer][i] > 0) {
                nextPlayerHasStones = true;
                break;
            }
        }

        // 如果下一个玩家没有石子，再次切换玩家
        if (!nextPlayerHasStones) {
            console.log(`${gameState.currentPlayer === 0 ? "玩家" : "系统"}没有石子可操作，跳过回合`);
            updateGameStatus(`${gameState.currentPlayer === 0 ? "玩家" : "系统"}没有石子可操作，跳过回合`);

            // 等待一段时间后再次切换玩家
            setTimeout(() => {
                gameState.currentPlayer = (gameState.currentPlayer + 1) % 2;

                // 再次检查当前玩家是否有石子可操作
                let currentPlayerHasStones = false;
                for (let i = 0; i < NUM_PITS; i++) {
                    if (gameState.board[gameState.currentPlayer][i] > 0) {
                        currentPlayerHasStones = true;
                        break;
                    }
                }

                // 如果双方都没有石子，游戏结束
                if (!currentPlayerHasStones) {
                    console.log("双方都没有石子可操作，游戏结束");
                    gameState.gameOver = true;
                    endGame();
                    return;
                }

                if (gameState.currentPlayer === 0) {
                    updateGameStatus('玩家回合，请选择一个格子');
                } else {
                    updateGameStatus('系统回合，系统正在思考...');
                    setTimeout(systemTurn, 1000);
                }

                updateSelectablePits();
            }, 1500);

            return;
        }

        if (gameState.currentPlayer === 0) {
            updateGameStatus('玩家回合，请选择一个格子');
        } else {
            updateGameStatus('系统回合，系统正在思考...');
            setTimeout(systemTurn, 1000);
        }

        updateSelectablePits();
    }

    // !!!!update
    // 修改检查游戏结束的条件
    function checkGameOver() {
        const WINNING_SCORE = 20; // 设置胜利分数为20

        // 检查分数是否达到胜利条件
        if (gameState.score[0] >= WINNING_SCORE || gameState.score[1] >= WINNING_SCORE) {
            gameState.gameOver = true;
            endGame();
            return true;
        }

        // 检查是否所有格子都为空（双方都没有石子可操作）
        let playerEmpty = true;
        let systemEmpty = true;

        for (let i = 0; i < NUM_PITS; i++) {
            if (gameState.board[0][i] > 0) playerEmpty = false;
            if (gameState.board[1][i] > 0) systemEmpty = false;
        }

        if (playerEmpty && systemEmpty) {
            gameState.gameOver = true;
            endGame();
            return true;
        }

        // 检查是否还剩有足够的石子使任何一方达到胜利
        const remainingStones = calculateRemainingStones();

        // 如果任一方的当前分数加上剩余所有石子也无法达到胜利条件，则游戏也应结束
        if (gameState.score[0] + remainingStones < WINNING_SCORE &&
            gameState.score[1] + remainingStones < WINNING_SCORE) {
            // 如果继续游戏也无法改变胜负，则游戏结束
            if (gameState.score[0] !== gameState.score[1]) { // 避免平局情况下提前结束
                gameState.gameOver = true;
                endGame();
                return true;
            }
        }

        return false;
    }
    // ++++new
    // 计算棋盘上剩余的所有石子数量
    function calculateRemainingStones() {
        let totalStones = 0;

        // 计算玩家和系统格子中的所有石子
        for (let player = 0; player < 2; player++) {
            for (let pit = 0; pit < NUM_PITS; pit++) {
                totalStones += gameState.board[player][pit];
            }
        }

        return totalStones;
    }
    // ++++new
    // 游戏结束处理函数
    // 在游戏结束时显示AI难度
    // !!!!update
    // 修改 endGame 函数，在游戏结束时显示AI难度
    function endGame() {
        const winner = gameState.score[0] > gameState.score[1] ? '玩家' : '系统';
        winnerMessage.textContent = `${winner}获胜！`;
        finalScore.textContent = `最终比分：玩家 ${gameState.score[0]} vs 系统 ${gameState.score[1]}`;

        // 添加AI难度信息
        const difficultyInfo = document.createElement('p');
        difficultyInfo.textContent = `AI难度: ${getDifficultyName(gameState.aiDifficulty)}`;
        finalScore.appendChild(difficultyInfo);

        setTimeout(() => {
            gameOverOverlay.style.display = 'flex';
        }, 1000);
    }

    // 显示游戏规则
    function showRules() {
        alert(
            "游戏规则：\n\n" +
            "1. 游戏为双人回合对弈\n" +
            "2. 每人前方有5个格子，每个格子中有四个石子\n" +
            "3. 通过石头剪子布确定先后手\n" +
            "4. 每人在自己的回合中，选择一个格子，将其中的石子拿起，选择一个方向，例如顺时针，从下一格子开始，依次放一个，直到手中没有石子，再拿起下一格子的所有石子，继续操作，直至手中没有石子，且下一格子为空，此时，下下一格子中的所有石子，归自己所有\n" +
            "5. 循环游戏，直至可以确定胜负，胜负判定条件为归玩家所有的石子数量，即其中一方玩家所有的石子超过总石子半数"
        );
    }

    // 重新开始游戏
    // 重置游戏时保留当前AI难度设置
    // !!!!update
    // 修改 restartGame 函数，重置游戏时保留当前AI难度设置，显示难度选择界面
    function restartGame() {
        // 保存当前AI难度
        const currentDifficulty = gameState.aiDifficulty;

        // 重置游戏状态
        gameState = {
            board: [
                [INITIAL_STONES, INITIAL_STONES, INITIAL_STONES, INITIAL_STONES, INITIAL_STONES],
                [INITIAL_STONES, INITIAL_STONES, INITIAL_STONES, INITIAL_STONES, INITIAL_STONES]
            ],
            score: [0, 0],
            currentPlayer: -1,
            gameStarted: false,
            gameOver: false,
            selectedPit: null,
            isAnimating: false,
            moveCount: 0,
            aiDifficulty: currentDifficulty // 保留当前AI难度
        };

        // 重置界面
        gameOverOverlay.style.display = 'none';
        rpsContainer.style.display = 'block';
        difficultyContainer.style.display = 'block';
        difficultyDisplay.style.display = 'none';
        directionButtons.style.display = 'none';
        startGameBtn.style.display = 'none';

        // 更新难度选择UI
        difficultyOptions.forEach(option => {
            option.classList.remove('selected');
            if (parseInt(option.dataset.difficulty) === currentDifficulty) {
                option.classList.add('selected');
            }
        });

        renderBoard();
        updateScores();
        updateGameStatus('请通过石头剪子布决定先手');
    }

    // 添加 HTML 元素 - 放在 game-container div 内部的最后位置
    function addLogWindow() {
        const logWindowHTML = `
        <div class="log-window-container">
            <h3>操作日志</h3>
            <div class="log-window" id="logWindow"></div>
            <button id="clearLogBtn">清空日志</button>
        </div>
    `;

        // 在游戏容器末尾添加日志窗口
        const gameContainer = document.querySelector('.game-container');
        gameContainer.insertAdjacentHTML('beforeend', logWindowHTML);

        // 添加清空日志按钮点击事件
        document.getElementById('clearLogBtn').addEventListener('click', clearLog);
    }

    // 添加样式 - 放在 <style> 标签内
    function addLogStyles() {
        const logStyles = `
        .log-window-container {
            margin-top: 30px;
            border-top: 2px solid #ddd;
            padding-top: 20px;
        }

        .log-window-container h3 {
            text-align: center;
            margin-bottom: 10px;
            color: #333;
        }

        .log-window {
            height: 250px;
            overflow-y: auto;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            background-color: #f9f9f9;
            font-family: monospace;
            white-space: pre-wrap;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .log-entry {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .log-header {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .log-player {
            color: #3498db;
        }

        .log-system {
            color: #e74c3c;
        }

        .log-pit {
            font-weight: bold;
            color: #27ae60;
        }

        .log-stones {
            color: #f39c12;
        }

        #clearLogBtn {
            padding: 5px 10px;
            background-color: #95a5a6;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        #clearLogBtn:hover {
            background-color: #7f8c8d;
        }

        .board-state {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            margin-top: 5px;
            font-size: 12px;
        }

        .board-row {
            display: contents;
        }

        .board-cell {
            text-align: center;
            padding: 3px;
            border-radius: 3px;
        }

        .board-cell.player {
            background-color: rgba(52, 152, 219, 0.2);
        }

        .board-cell.system {
            background-color: rgba(231, 76, 60, 0.2);
        }

        .board-cell.active {
            font-weight: bold;
            color: white;
        }

        .board-cell.active.player {
            background-color: rgba(52, 152, 219, 0.8);
        }

        .board-cell.active.system {
            background-color: rgba(231, 76, 60, 0.8);
        }

        .log-timestamp {
            color: #95a5a6;
            font-size: 12px;
            margin-bottom: 3px;
        }
    `;

        // 添加样式到页面
        const styleElement = document.createElement('style');
        styleElement.textContent = logStyles;
        document.head.appendChild(styleElement);
    }

    // 添加日志条目
    function addLogEntry(player, pitIndex, beforeStones, afterStones, boardStateBefore, boardStateAfter) {
        const logWindow = document.getElementById('logWindow');
        if (!logWindow) return;

        // 获取当前时间
        const now = new Date();
        const timestamp = now.toLocaleTimeString('zh-CN', { hour12: false });

        // 创建日志条目
        const logEntry = document.createElement('div');
        logEntry.className = 'log-entry';

        // 玩家类型文本
        const playerText = player === 0 ? "玩家" : "系统";
        const playerClass = player === 0 ? "log-player" : "log-system";

        // 格子全局编号
        const globalPitIndex = player === 0 ? pitIndex + 1 : pitIndex + 6;

        // 创建日志头部
        const logHeader = document.createElement('div');
        logHeader.className = 'log-header';
        logHeader.innerHTML = `<span class="log-timestamp">[${timestamp}]</span><br><span class="${playerClass}">${playerText}</span> 操作格子 <span class="log-pit">${globalPitIndex}</span>：<span class="log-stones">${beforeStones}</span> → <span class="log-stones">${afterStones}</span>`;

        // 创建棋盘状态显示
        const boardStateDisplay = document.createElement('div');
        boardStateDisplay.innerHTML = createBoardStateHTML(player, pitIndex, boardStateBefore, boardStateAfter);

        // 将组件添加到日志条目
        logEntry.appendChild(logHeader);
        logEntry.appendChild(boardStateDisplay);

        // 添加到日志窗口
        logWindow.appendChild(logEntry);

        // 滚动到底部
        logWindow.scrollTop = logWindow.scrollHeight;
    }

    // 创建棋盘状态 HTML
    function createBoardStateHTML(player, pitIndex, boardStateBefore, boardStateAfter) {
        let html = '<div class="board-state">';

        // 添加"操作前"标题
        html += '<div class="board-row">';
        html += `<div class="board-cell" style="grid-column: span 5; text-align:left; font-weight:bold; color:#555;">操作前：</div>`;
        html += '</div>';

        // 系统格子（1行，从6到10）
        html += '<div class="board-row">';
        for (let i = 0; i < 5; i++) {
            const isActive = player === 1 && pitIndex === i;
            const cellClass = `board-cell system${isActive ? ' active' : ''}`;
            html += `<div class="${cellClass}">格子${i+6}: ${boardStateBefore[1][i]}</div>`;
        }
        html += '</div>';

        // 玩家格子（1行，从1到5）
        html += '<div class="board-row">';
        for (let i = 0; i < 5; i++) {
            const isActive = player === 0 && pitIndex === i;
            const cellClass = `board-cell player${isActive ? ' active' : ''}`;
            html += `<div class="${cellClass}">格子${i+1}: ${boardStateBefore[0][i]}</div>`;
        }
        html += '</div>';

        // 添加"操作后"标题
        html += '<div class="board-row" style="margin-top: 5px">';
        html += `<div class="board-cell" style="grid-column: span 5; text-align:left; font-weight:bold; color:#555;">操作后：</div>`;
        html += '</div>';

        // 系统格子（1行，从6到10）
        html += '<div class="board-row">';
        for (let i = 0; i < 5; i++) {
            const cellClass = `board-cell system`;
            html += `<div class="${cellClass}">格子${i+6}: ${boardStateAfter[1][i]}</div>`;
        }
        html += '</div>';

        // 玩家格子（1行，从1到5）
        html += '<div class="board-row">';
        for (let i = 0; i < 5; i++) {
            const cellClass = `board-cell player`;
            html += `<div class="${cellClass}">格子${i+1}: ${boardStateAfter[0][i]}</div>`;
        }
        html += '</div>';

        html += '</div>';
        return html;
    }

    // 清空日志
    function clearLog() {
        const logWindow = document.getElementById('logWindow');
        if (logWindow) {
            logWindow.innerHTML = '';
        }
    }

    // 复制当前棋盘状态
    function cloneBoardState(board) {
        return [
            [...board[0]],  // 玩家格子
            [...board[1]]   // 系统格子
        ];
    }

    // 修改 makeMove 函数以记录日志
    function logMoveStart(player, pitIndex, stones) {
        // 复制当前棋盘状态
        const boardStateBefore = cloneBoardState(gameState.board);

        // 记录操作前状态
        addLogEntry(
            player,
            pitIndex,
            stones,  // 操作前石子数
            0,       // 操作后石子数（拿起所有石子）
            boardStateBefore,
            cloneBoardState(gameState.board)  // 操作后的状态
        );
    }

    // 修改 finishMove 函数以记录捕获日志
    function logCapture(player, capturePlayer, capturePit, capturedStones) {
        // 复制当前棋盘状态
        const boardStateBefore = cloneBoardState(gameState.board);

        // 手动修改以创建"操作前"状态
        boardStateBefore[capturePlayer][capturePit] = capturedStones;

        // 记录捕获日志
        addLogEntry(
            player,  // 执行捕获的玩家
            -1,      // 使用-1表示这是捕获操作而非普通移动
            capturedStones,
            0,
            boardStateBefore,
            cloneBoardState(gameState.board)
        );
    }

    // 初始化日志功能
    function initLogWindow() {
        addLogStyles();
        addLogWindow();
    }


    // 页面加载时初始化游戏
    window.addEventListener('load', function() {
        // 在页面完全加载后添加日志窗口
        updatePitStyles();
        updateStoneStyles();
        updateDistributionStoneStyles();

        setTimeout(initEnhancedVisuals, 100);
        setTimeout(initLogWindow, 100);
        initGame()
    });
</script>
</body>
</html>
